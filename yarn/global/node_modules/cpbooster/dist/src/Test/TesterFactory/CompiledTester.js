"use strict";
/*
    cpbooster "Competitive Programming Booster"
    Copyright (C) 2020  Sergio G. Sanchez V.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __spreadArrays = (this && this.__spreadArrays) || function () {
    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;
    for (var r = Array(s), k = 0, i = 0; i < il; i++)
        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
            r[k] = a[j];
    return r;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.NonStandardCompilers = void 0;
var Path = __importStar(require("path"));
var fs = __importStar(require("fs"));
var chalk_1 = __importDefault(require("chalk"));
var Util_1 = __importDefault(require("../../Utils/Util"));
var child_process_1 = require("child_process");
var process_1 = require("process");
var Veredict_1 = require("../../Types/Veredict");
var Tester_1 = __importDefault(require("./Tester"));
// Todo: If the list increases significantly, creating a Set containing
// the enum values would be reasonable for quick access.
var NonStandardCompilers;
(function (NonStandardCompilers) {
    NonStandardCompilers["mcs"] = "mcs";
    NonStandardCompilers["csc"] = "csc";
})(NonStandardCompilers = exports.NonStandardCompilers || (exports.NonStandardCompilers = {}));
var CompiledTester = /** @class */ (function (_super) {
    __extends(CompiledTester, _super);
    function CompiledTester(config, filePath) {
        return _super.call(this, config, filePath) || this;
    }
    CompiledTester.prototype.testOne = function (testId, shouldCompile) {
        var binaryFileName = this.getExecutableFileNameOrDefault(false);
        var binaryFilePath = "." + Path.sep + binaryFileName;
        var hasValidConditions = function () {
            var result = { status: true, feedback: "" };
            if (!fs.existsSync(binaryFilePath)) {
                result = {
                    status: false,
                    feedback: chalk_1.default.red("Error:") + " Executable " + binaryFilePath + " not found"
                };
            }
            return result;
        };
        var _a = this.getTestVeredict(binaryFilePath, [], testId, hasValidConditions, shouldCompile, this.compile.bind(this)), veredict = _a.veredict, feedback = _a.feedback;
        this.printTestResults(veredict, feedback, testId);
        return veredict;
    };
    CompiledTester.prototype.debugOne = function (testId, compile) {
        var binaryFileName = this.getExecutableFileNameOrDefault(true);
        var binaryFilePath = "." + Path.sep + binaryFileName;
        if (compile) {
            var _a = this.compile(true), status = _a.status, feedback = _a.feedback;
            if (!status) {
                this.printTestResults(Veredict_1.Veredict.CE, feedback, testId);
                process_1.exit(0);
            }
        }
        else if (!fs.existsSync(binaryFilePath)) {
            console.log(chalk_1.default.red("Error:"), "Executable " + binaryFilePath + " not found");
            process_1.exit(0);
        }
        this.runDebug(binaryFilePath, [], testId);
    };
    CompiledTester.prototype.debugWithUserInput = function (compile) {
        var binaryFileName = this.getExecutableFileNameOrDefault(true);
        var binaryFilePath = "." + Path.sep + binaryFileName;
        if (compile) {
            var _a = this.compile(true), status = _a.status, feedback = _a.feedback;
            if (!status) {
                this.printTestResults(Veredict_1.Veredict.CE, feedback, 0);
                process_1.exit(0);
            }
        }
        else if (!fs.existsSync(binaryFilePath)) {
            console.log(chalk_1.default.red("Error:"), "Executable " + binaryFilePath + " not found");
            process_1.exit(0);
        }
        this.runDebugWithUserInput(binaryFilePath);
    };
    CompiledTester.prototype.getExecutableFileName = function (debug) {
        var segmentedCommand = this.getSegmentedCommand(this.langExtension, debug);
        var compilerCommand = this.getCompilerCommand(this.langExtension, debug);
        var fileNameOption = CompiledTester.getFileNameOptionForCompilerCommand(compilerCommand);
        for (var i = 0; i < segmentedCommand.length; i++) {
            if (segmentedCommand[i].startsWith(fileNameOption)) {
                if (Object.keys(NonStandardCompilers).includes(compilerCommand)) {
                    // using pop to reduce amount of code to return the last element
                    return segmentedCommand[i].split(":").pop();
                }
                else {
                    return segmentedCommand[i + 1];
                }
            }
        }
        return undefined;
    };
    CompiledTester.prototype.getDefaultExecutableFileName = function (debug) {
        var defaultName = Util_1.default.replaceAll(Path.parse(this.filePath).name, " ", "");
        if (debug)
            defaultName += "debug";
        defaultName += ".exe";
        return defaultName;
    };
    CompiledTester.prototype.getExecutableFileNameOrDefault = function (debug) {
        var _a;
        return (_a = this.getExecutableFileName(debug)) !== null && _a !== void 0 ? _a : this.getDefaultExecutableFileName(debug);
    };
    CompiledTester.getFileNameOptionForCompilerCommand = function (compilerCommand) {
        var _a;
        return (_a = CompiledTester.fileNameOptionForCommand.get(compilerCommand)) !== null && _a !== void 0 ? _a : "-o";
    };
    CompiledTester.printCompilingMsg = function () {
        console.log("Compiling...\n");
    };
    CompiledTester.executeCompilation = function (compilerCommand, args) {
        var result = { status: true, feedback: "" };
        var compilation = child_process_1.spawnSync(compilerCommand, args);
        if (compilation.stderr) {
            // if (compilation.stderr || compilation.status !== 0) {
            var compileStderr = Buffer.from(compilation.stderr).toString("utf8").trim();
            if (compileStderr !== "") {
                // TODO: replace with regex instead of split and join ignoring case
                compileStderr = compileStderr.split("error").join(chalk_1.default.redBright("error"));
                compileStderr = compileStderr.split("warning").join(chalk_1.default.blueBright("warning"));
                // TODO: replace with regex match ignoring case
                if (compileStderr.includes("error")) {
                    result.status = false;
                }
                result.feedback = compileStderr;
            }
        }
        return result;
    };
    CompiledTester.prototype.compile = function (debug) {
        CompiledTester.printCompilingMsg();
        var segmentedCommand = this.getSegmentedCommand(this.langExtension, debug);
        var args = __spreadArrays(segmentedCommand.slice(1));
        var compilerCommand = this.getCompilerCommand(this.langExtension, debug);
        if (!this.getExecutableFileName(debug)) {
            if (Object.keys(NonStandardCompilers).includes(compilerCommand)) {
                args.push(CompiledTester.getFileNameOptionForCompilerCommand(compilerCommand) +
                    this.getDefaultExecutableFileName(debug));
            }
            else {
                args.push(CompiledTester.getFileNameOptionForCompilerCommand(compilerCommand), this.getDefaultExecutableFileName(debug));
            }
        }
        args.push(this.filePath);
        return CompiledTester.executeCompilation(compilerCommand, args);
    };
    CompiledTester.fileNameOptionForCommand = new Map([
        [NonStandardCompilers.mcs, "-out:"],
        [NonStandardCompilers.csc, "/out:"] // csharp compiler
    ]);
    return CompiledTester;
}(Tester_1.default));
exports.default = CompiledTester;
