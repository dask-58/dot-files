"use strict";
/*
    cpbooster "Competitive Programming Booster"
    Copyright (C) 2020  Sergio G. Sanchez V.

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <https://www.gnu.org/licenses/>.
 */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var Veredict_1 = require("../../Types/Veredict");
var Tester_1 = __importDefault(require("./Tester"));
var chalk_1 = __importDefault(require("chalk"));
var Path = __importStar(require("path"));
var fs = __importStar(require("fs"));
var process_1 = require("process");
var CompiledTester_1 = __importDefault(require("./CompiledTester"));
var LangExtensions_1 = require("../../Utils/LangExtensions");
var MixedTester = /** @class */ (function (_super) {
    __extends(MixedTester, _super);
    function MixedTester(config, filePath) {
        return _super.call(this, config, filePath) || this;
    }
    MixedTester.prototype.getExecutableFileName = function () {
        return "" + this.getExecutableFileNameNoExtension() + (this.langExtension === LangExtensions_1.LangExtensions.kotlin ? "Kt" : "") + ".class";
    };
    MixedTester.prototype.getExecutableFileNameNoExtension = function () {
        return (Path.basename(this.filePath).replace("." + this.langExtension, "") +
            (this.langExtension === LangExtensions_1.LangExtensions.kotlin ? "Kt" : ""));
    };
    MixedTester.prototype.testOne = function (testId, shouldCompile) {
        var executableFileName = this.getExecutableFileName();
        var hasValidConditions = function () {
            var result = { status: true, feedback: "" };
            if (!fs.existsSync(executableFileName)) {
                result = {
                    status: false,
                    feedback: chalk_1.default.red("Error:") + " Executable " + executableFileName + " not found, Is your class name same as the file name ?"
                };
            }
            return result;
        };
        var langConfig = this.config.languages[this.langExtension];
        if (langConfig === null || langConfig === void 0 ? void 0 : langConfig.runCommand) {
            var segmentedRunCommand = langConfig.runCommand.split(" ");
            segmentedRunCommand.push(this.getExecutableFileNameNoExtension());
            var _a = this.getTestVeredict(segmentedRunCommand[0], segmentedRunCommand.slice(1), testId, hasValidConditions, shouldCompile, this.compile.bind(this) // attaching compile function to `this` context
            ), veredict = _a.veredict, feedback = _a.feedback;
            this.printTestResults(veredict, feedback, testId);
            return veredict;
        }
        else {
            console.log("runCommand not specified for " + this.langExtension + " files");
            process_1.exit(0);
        }
    };
    MixedTester.prototype.compile = function (debug) {
        CompiledTester_1.default.printCompilingMsg();
        var segmentedCommand = this.getSegmentedCommand(this.langExtension, debug);
        var args = segmentedCommand.slice(1);
        var compilerCommand = this.getCompilerCommand(this.langExtension, debug);
        args.push(this.filePath);
        return CompiledTester_1.default.executeCompilation(compilerCommand, args);
    };
    MixedTester.prototype.debugOne = function (testId, compile) {
        var executableFileName = this.getExecutableFileName();
        if (compile) {
            var _a = this.compile(true), status = _a.status, feedback = _a.feedback;
            if (!status) {
                this.printTestResults(Veredict_1.Veredict.CE, feedback, testId);
                process_1.exit(0);
            }
        }
        else if (!fs.existsSync(executableFileName)) {
            console.log(chalk_1.default.red("Error:"), "Executable " + executableFileName + " not found, Is your class name same as the file name?");
            process_1.exit(0);
        }
        var langConfig = this.config.languages[this.langExtension];
        if (langConfig.runCommand) {
            var segmentedRunCommand = langConfig.runCommand.split(" ");
            segmentedRunCommand.push(this.getExecutableFileNameNoExtension());
            return this.runDebug(segmentedRunCommand[0], segmentedRunCommand.slice(1), testId);
        }
        else {
            console.log("runCommand not specified for " + this.langExtension + " files");
            process_1.exit(0);
        }
    };
    MixedTester.prototype.debugWithUserInput = function (compile) {
        var executableFileName = this.getExecutableFileName();
        if (compile) {
            var _a = this.compile(true), status = _a.status, feedback = _a.feedback;
            if (!status) {
                this.printTestResults(Veredict_1.Veredict.CE, feedback, 0);
                process_1.exit(0);
            }
        }
        else if (!fs.existsSync(executableFileName)) {
            console.log(chalk_1.default.red("Error:"), "Executable " + executableFileName + " not found, Is your class name same as the file name?");
            process_1.exit(0);
        }
        var langConfig = this.config.languages[this.langExtension];
        if (langConfig.runCommand) {
            var segmentedRunCommand = langConfig.runCommand.split(" ");
            segmentedRunCommand.push(this.getExecutableFileNameNoExtension());
            return this.runDebugWithUserInput(segmentedRunCommand[0], segmentedRunCommand.slice(1));
        }
        else {
            console.log("runCommand not specified for " + this.langExtension + " files");
            process_1.exit(0);
        }
    };
    return MixedTester;
}(Tester_1.default));
exports.default = MixedTester;
